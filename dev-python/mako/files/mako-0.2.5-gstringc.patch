diff -ur Mako-0.2.5.orig/lib/mako/filters.py Mako-0.2.5/lib/mako/filters.py
--- Mako-0.2.5.orig/lib/mako/filters.py	2009-09-07 21:28:05.000000000 +0200
+++ Mako-0.2.5/lib/mako/filters.py	2010-02-11 23:53:09.919401000 +0100
@@ -6,7 +6,7 @@
 
 
 import re, cgi, urllib, htmlentitydefs, codecs
-from StringIO import StringIO
+from gstringc import GString
 
 xml_escapes = {
     '&' : '&amp;',
diff -ur Mako-0.2.5.orig/lib/mako/pygen.py Mako-0.2.5/lib/mako/pygen.py
--- Mako-0.2.5.orig/lib/mako/pygen.py	2009-09-07 21:28:05.000000000 +0200
+++ Mako-0.2.5/lib/mako/pygen.py	2010-02-11 23:53:38.189401000 +0100
@@ -7,7 +7,7 @@
 """utilities for generating and formatting literal Python code."""
 
 import re, string
-from StringIO import StringIO
+from gstringc import GString
 
 class PythonPrinter(object):
     def __init__(self, stream):
diff -ur Mako-0.2.5.orig/lib/mako/pyparser.py Mako-0.2.5/lib/mako/pyparser.py
--- Mako-0.2.5.orig/lib/mako/pyparser.py	2009-09-07 21:28:05.000000000 +0200
+++ Mako-0.2.5/lib/mako/pyparser.py	2010-02-11 23:59:27.479401000 +0100
@@ -10,7 +10,7 @@
 module is used.
 """
 
-from StringIO import StringIO
+from gstringc import GString
 from mako import exceptions, util
 
 # words that cannot be assigned to (notably smaller than the total keys in __builtins__)
@@ -238,28 +238,28 @@
     class ExpressionGenerator(object):
         """given an AST node, generates an equivalent literal Python expression."""
         def __init__(self, astnode):
-            self.buf = StringIO()
+            self.buf = GString()
             visitor.walk(astnode, self) #, walker=walker())
         def value(self):
-            return self.buf.getvalue()        
+            return self.buf.get_value()        
         def operator(self, op, node, *args):
-            self.buf.write("(")
+            self.buf += "("
             self.visit(node.left, *args)
-            self.buf.write(" %s " % op)
+            self.buf += " %s " % op
             self.visit(node.right, *args)
-            self.buf.write(")")
+            self.buf += ")"
         def booleanop(self, op, node, *args):
             self.visit(node.nodes[0])
             for n in node.nodes[1:]:
-                self.buf.write(" " + op + " ")
+                self.buf += " " + op + " "
                 self.visit(n, *args)
         def visitConst(self, node, *args):
-            self.buf.write(repr(node.value))
+            self.buf += repr(node.value)
         def visitAssName(self, node, *args):
             # TODO: figure out OP_ASSIGN, other OP_s
-            self.buf.write(node.name)
+            self.buf += node.name
         def visitName(self, node, *args):
-            self.buf.write(node.name)
+            self.buf += node.name
         def visitMul(self, node, *args):
             self.operator("*", node, *args)
         def visitAnd(self, node, *args):
@@ -276,11 +276,11 @@
             self.operator("+", node, *args)
         def visitGetattr(self, node, *args):
             self.visit(node.expr, *args)
-            self.buf.write(".%s" % node.attrname)
+            self.buf += ".%s" % node.attrname
         def visitSub(self, node, *args):
             self.operator("-", node, *args)
         def visitNot(self, node, *args):
-            self.buf.write("not ")
+            self.buf += "not "
             self.visit(node.expr)
         def visitDiv(self, node, *args):
             self.operator("/", node, *args)
@@ -288,81 +288,81 @@
             self.operator("//", node, *args)
         def visitSubscript(self, node, *args):
             self.visit(node.expr)
-            self.buf.write("[")
+            self.buf += "["
             [self.visit(x) for x in node.subs]
-            self.buf.write("]")
+            self.buf += "]"
         def visitUnarySub(self, node, *args):
-            self.buf.write("-")
+            self.buf += "-"
             self.visit(node.expr)
         def visitUnaryAdd(self, node, *args):
-            self.buf.write("-")
+            self.buf += "-"
             self.visit(node.expr)
         def visitSlice(self, node, *args):
             self.visit(node.expr)
-            self.buf.write("[")
+            self.buf += "["
             if node.lower is not None:
                 self.visit(node.lower)
-            self.buf.write(":")
+            self.buf += ":"
             if node.upper is not None:
                 self.visit(node.upper)
-            self.buf.write("]")
+            self.buf += "]"
         def visitDict(self, node):
-            self.buf.write("{")
+            self.buf += "{"
             c = node.getChildren()
             for i in range(0, len(c), 2):
                 self.visit(c[i])
-                self.buf.write(": ")
+                self.buf += ": "
                 self.visit(c[i+1])
                 if i<len(c) -2:
-                    self.buf.write(", ")
-            self.buf.write("}")
+                    self.buf += ", "
+            self.buf += "}"
         def visitTuple(self, node):
-            self.buf.write("(")
+            self.buf += "("
             c = node.getChildren()
             for i in range(0, len(c)):
                 self.visit(c[i])
                 if i<len(c) - 1:
-                    self.buf.write(", ")
-            self.buf.write(")")
+                    self.buf += ", "
+            self.buf += ")"
         def visitList(self, node):
-            self.buf.write("[")
+            self.buf += "["
             c = node.getChildren()
             for i in range(0, len(c)):
                 self.visit(c[i])
                 if i<len(c) - 1:
-                    self.buf.write(", ")
-            self.buf.write("]")
+                    self.buf += ", "
+            self.buf += "]"
         def visitListComp(self, node):
-            self.buf.write("[")
+            self.buf += "["
             self.visit(node.expr)
-            self.buf.write(" ")
+            self.buf += " "
             for n in node.quals:
                 self.visit(n)
-            self.buf.write("]")
+            self.buf += "]"
         def visitListCompFor(self, node):
-            self.buf.write(" for ")
+            self.buf += " for "
             self.visit(node.assign)
-            self.buf.write(" in ")
+            self.buf += " in "
             self.visit(node.list)
             for n in node.ifs:
                 self.visit(n)
         def visitListCompIf(self, node):
-            self.buf.write(" if ")
+            self.buf += " if "
             self.visit(node.test)
         def visitCompare(self, node):
             self.visit(node.expr)
             for tup in node.ops:
-                self.buf.write(tup[0])
+                self.buf += tup[0]
                 self.visit(tup[1])
         def visitCallFunc(self, node, *args):
             self.visit(node.node)
-            self.buf.write("(")
+            self.buf += "("
             if len(node.args):
                 self.visit(node.args[0])
                 for a in node.args[1:]:
-                    self.buf.write(", ")
+                    self.buf += ", "
                     self.visit(a)
-            self.buf.write(")")
+            self.buf += ")"
 
     class walker(visitor.ASTVisitor):
         def dispatch(self, node, *args):
diff -ur Mako-0.2.5.orig/lib/mako/runtime.py Mako-0.2.5/lib/mako/runtime.py
--- Mako-0.2.5.orig/lib/mako/runtime.py	2009-09-07 21:28:05.000000000 +0200
+++ Mako-0.2.5/lib/mako/runtime.py	2010-02-12 00:17:27.039401000 +0100
@@ -78,7 +78,7 @@
     def writer(self):
         """return the current writer function"""
 
-        return self._buffer_stack[-1].write
+        return self._buffer_stack[-1].__iadd__
 
     def _copy(self):
         c = Context.__new__(Context)
@@ -353,12 +353,14 @@
 def _render(template, callable_, args, data, as_unicode=False):
     """create a Context and return the string output of the given template and template callable."""
 
-    if as_unicode:
-        buf = util.FastEncodingBuffer(unicode=True)
-    elif template.output_encoding:
-        buf = util.FastEncodingBuffer(unicode=as_unicode, encoding=template.output_encoding, errors=template.encoding_errors)
-    else:
-        buf = util.StringIO()
+#    if as_unicode:
+#        buf = util.FastEncodingBuffer(unicode=True)
+#    elif template.output_encoding:
+#        buf = util.FastEncodingBuffer(unicode=as_unicode, encoding=template.output_encoding, errors=template.encoding_errors)
+#    else:
+#        buf = util.StringIO()
+    from gstringc import GString
+    buf = GString
     context = Context(buf, **data)
     context._with_template = template
     _render_context(template, callable_, context, *args, **_kwargs_for_callable(callable_, data))
